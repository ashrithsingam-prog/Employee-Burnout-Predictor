import os
import uuid
from datetime import datetime
from functools import wraps

from flask import Flask, jsonify, request, render_template, abort
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from dotenv import load_dotenv

# 1. SETUP & CONFIGURATION
load_dotenv()
app = Flask(__name__)

# Security Config
app.config.update(
    SECRET_KEY=os.getenv('SECRET_KEY', 'SUPER_SECRET_NON_GUESSABLE_KEY_123'),
    SQLALCHEMY_DATABASE_URI='sqlite:///burnout_secure.db',
    SQLALCHEMY_TRACK_MODIFICATIONS=False,
    SESSION_COOKIE_HTTPONLY=True,
    SESSION_COOKIE_SECURE=False, # Set to True in production with HTTPS
    SESSION_COOKIE_SAMESITE='Lax'
)

db = SQLAlchemy(app)
bcrypt = Bcrypt(app)
login_manager = LoginManager(app)
login_manager.login_view = "login"

# Rate Limiting to prevent brute force
limiter = Limiter(get_remote_address, app=app, default_limits=["200 per day"])

# 2. DATABASE MODELS
class User(db.Model, UserMixin):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    emp_id = db.Column(db.String(20), unique=True, nullable=False)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    role = db.Column(db.String(20), default='employee') # 'employee' or 'hr'
    department = db.Column(db.String(50))
    
    assessments = db.relationship('Assessment', backref='owner', lazy=True)

class Assessment(db.Model):
    __tablename__ = 'assessments'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    score = db.Column(db.Float, nullable=False)
    risk_level = db.Column(db.String(20)) # Low, Moderate, High, Critical
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

# Initialize Database
with app.app_context():
    db.create_all()

# 3. AUTHENTICATION HELPERS
@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))

def hr_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role != 'hr':
            return jsonify({"error": "Unauthorized. HR access required."}), 403
        return f(*args, **kwargs)
    return decorated_function

# 4. API ROUTES

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/api/register", methods=["POST"])
@limiter.limit("5 per hour")
def register():
    data = request.get_json()
    if User.query.filter_by(email=data['email']).first():
        return jsonify({"error": "User already exists"}), 400
    
    hashed_pw = bcrypt.generate_password_hash(data['password']).decode('utf-8')
    new_user = User(
        emp_id=f"EMP{uuid.uuid4().hex[:4].upper()}",
        name=data['name'],
        email=data['email'],
        password_hash=hashed_pw,
        role=data.get('role', 'employee'),
        department=data.get('department', 'General')
    )
    db.session.add(new_user)
    db.session.commit()
    return jsonify({"success": True, "message": "User registered successfully"})

@app.route("/api/login", methods=["POST"])
@limiter.limit("10 per minute")
def login():
    data = request.get_json()
    user = User.query.filter_by(email=data.get('email')).first()
    
    if user and bcrypt.check_password_hash(user.password_hash, data.get('password')):
        login_user(user)
        return jsonify({"success": True, "role": user.role, "name": user.name})
    
    return jsonify({"error": "Invalid email or password"}), 401

@app.route("/api/logout")
@login_required
def logout():
    logout_user()
    return jsonify({"success": True})

# 5. WORKER & HR FUNCTIONALITY

@app.route("/api/chat", methods=["POST"])
@login_required
def chat():
    data = request.get_json()
    msg = data.get("message", "").lower()
    
    # Mock AI logic for schedule/wellness
    if "schedule" in msg:
        reply = "You have a team meeting at 2 PM and no late shifts scheduled this week."
    elif "burnout" in msg or "tired" in msg:
        reply = "I've noticed your recent activity is high. Consider taking a 15-minute break."
    else:
        reply = "I'm your wellness assistant. Ask me about your schedule or how to manage stress!"
        
    return jsonify({"reply": reply})

@app.route("/api/hr/dashboard", methods=["GET"])
@login_required
@hr_required
def hr_dashboard():
    # Fetch all users and their latest scores
    employees = User.query.filter_by(role='employee').all()
    results = []
    for emp in employees:
        last_assessment = Assessment.query.filter_by(user_id=emp.id).order_by(Assessment.timestamp.desc()).first()
        results.append({
            "name": emp.name,
            "dept": emp.department,
            "risk": last_assessment.risk_level if last_assessment else "No Data",
            "score": last_assessment.score if last_assessment else 0
        })
    return jsonify({"employees": results})

if __name__ == "__main__":
    # NEVER use debug=True in a real production environment
    app.run(debug=True, port=5000)
